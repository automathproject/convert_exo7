/** =============================================================
 *
 * Symbols, whitespaces, strings and identifiers
 *
 * Identifiers may begin with a digit but, can consist solely of digits only if quoted.
 *
 * https://mariadb.com/kb/en/library/sql-language-structure/
 * https://mariadb.com/kb/en/library/operators/
 */
declare const _default: {
    /**
     * Whitespaces, also expect SQL comments
     */
    WS: {
        match: RegExp;
        lineBreaks: boolean;
    };
    S_EQUAL: string;
    S_LPARENS: string;
    S_RPARENS: string;
    S_COMMA: string;
    S_SEMICOLON: string;
    /**
     * Used to represent a bit datatype.
     */
    S_BIT_FORMAT: {
        match: RegExp;
    };
    /**
     * Used to represent a bit datatype.
     */
    S_HEXA_FORMAT: {
        match: RegExp;
    };
    /**
     * These RegExps support all types of quote escaping in MariaDB.
     *
     * @example
     * In the sentence below, the pointed positions are matched:
     *
     * I "match", "", "an \"escaped quote\"", also a "double double "" quote".
     *   ^^^^^^^  ^^  ^^^^^^^^^^^^^^^^^^^^^^         ^^^^^^^^^^^^^^^^^^^^^^^^
     */
    S_DQUOTE_STRING: {
        match: RegExp;
        value: (v: string) => string;
    };
    S_SQUOTE_STRING: {
        match: RegExp;
        value: (v: string) => string;
    };
    S_NUMBER: {
        match: RegExp;
        value: NumberConstructor;
    };
    /**
     * See S_IDENTIFIER in lexer.ne file.
     *
     * I've noticed through tests in the MariaDB CLI that escaped backticks are not
     * supported, they are interpreted as non-escaped backticks. Escaping
     * backticks is done through using double backticks. ~ duartealexf
     */
    S_IDENTIFIER_QUOTED: {
        match: RegExp;
        value: (v: string) => string;
    };
    S_IDENTIFIER_UNQUOTED: {
        match: RegExp;
    };
    /**
     * Fallback wildcard match.
     */
    S_UNKNOWN: {
        match: RegExp;
    };
};
export default _default;
